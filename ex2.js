/*

Перед ковбоем Джо выложены n карт со значениями a_1, a_2, … , a_n. Он хочет получить выигрышную последовательность карт со значениями b_1, b_2, … , b_n.
Ковбой может выбрать непрерывный отрезок карт в своей последовательности [l,r] (1 ≤ l ≤ r ≤ n) и упорядочить карты в этом отрезке по неубыванию. 
Например, если перед ковбоем лежат карты {3, 3, 2, 5, 1, 5}, он может выбрать отрезок [2, 5]
и получить последовательность {3,1,2,3,5,5}.
Получится ли у ковбоя Джо получить выигрышную последовательность с помощью применения вышеописанной операции ровно один раз? 

Формат входных данных

В первой строке дано целое число n (1 ≤ n ≤ 2 * 10^5) — количество карт в последовательности.
Во второй строке даны n целых чисел a_1, a_2, … , a_n(1 ≤ a_i ≤ 10^9) — последовательность ковбоя Джо.
В третьей строке даны n целых чисел b_1, b_2, … , b_n(1 ≤ b_i ≤ 10^9) — выигрышная последовательность.

Формат выходных данных

Выведите «YES» (без кавычек), если Джо может получить выигрышную последовательность, иначе выведите «NO».

*/

// подключаем модуль для взаимодействия с консолью
const readline = require('readline');

// создаем интерфейс для ввода и вывода данных
const rl = readline.createInterface({
  input: process.stdin,  // ввод с консоли
  output: process.stdout // вывод на консоль
});

// функция проверяет, можно ли получить выигрышную последовательность из двух массивов
function canGetWinningSequence(n, a, b) {
  let left = -1; // индекс начала отрезка
  let right = -1; // индекс конца отрезка

  // проходим по массивам и ищем первый несовпадающий элемент
  for (let i = 0; i < n; i++) {
    if (a[i] !== b[i]) {
      if (left === -1) {
        left = i; // устанавливаем индекс начала отрезка
      }
      right = i; // обновляем индекс конца отрезка при каждом несовпадении
    }
  }

  // если -1, значит, массивы идентичны, и можно получить выигрышную последовательность
  if (left === -1) {
    return "YES";
  }

  // проверяем, можно ли упорядочить отрезок так, чтобы он стал равен b
  const sortedSegment = a.slice(left, right + 1).sort((x, y) => x - y);

  for (let i = left; i <= right; i++) {
    a[i] = sortedSegment[i - left];
  }

  // если получившийся массив a равен массиву b, то можно получить выигрышную последовательность
  if (arraysAreEqual(a, b)) {
    return "YES";
  } else {
    return "NO"; // иначе не получится получить выигрышную последовательность
  }
}

// сравнение двух массивов на идентичность
function arraysAreEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false; // если длины массивов разные, они не могут быть идентичными
  }

  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false; // если хотя бы один элемент различается, массивы не идентичны
    }
  }

  return true; // если не было несовпадений, массивы идентичны
}

// запрашиваем у пользователя данные
rl.question('', (n) => {
  rl.question('', (aStr) => {
    rl.question('', (bStr) => {
      // преобразуем введенные строки в массивы чисел
      const a = aStr.split(' ').map(Number);
      const b = bStr.split(' ').map(Number);

      // вызываем функцию и выводим результат
      const result = canGetWinningSequence(n, a, b);
      console.log(result);

      // закрываем интерфейс
      rl.close();
    });
  });
});

