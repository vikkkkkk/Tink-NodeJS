/* 

Древний индейский дух Чогэн пробудился и отправился карать бледнолицых. Ничто не способно его остановить, так что ковбой 
Джо выступает в роли наблюдателя в этой задаче.

На Диком западе n городов и m двусторонних дорог между ними. Штатом называется такое множества городов, для которого верно:
Из любого города этого множества можно добраться по дорогам до любого другого города из этого множества;
Из любого города этого множества нельзя добраться по дорогам до любого города не из этого множества.
Из любого города можно добраться по дорогам до самого себя, используя 0 дорог.
Дух Чогэн выбирает целое число x и уничтожает все дороги длиной не более x. Несложно заметить, что Дикий запад однозначно разбивается на штаты. Дух Чогэн хочет уничтожить как можно больше 
дорог, но количество штатов должно остаться неизменным. Помогите духу выбрать число x.

Формат входных данных:

В первой строке даны целые числа n,m (2 ≤ n ≤ 2 * 10^5,  1 ≤ m ≤ 2 * 10^5) — количество городов и дорог.
В следующих m строках даны целые числа v,u,w (1 ≤ v, u ≤ n, 1 ≤ w ≤ 10^9) — номера городов, соединенных дорогой и её длина.
Между какими-то городами могут быть проведены несколько дорог, также могут быть дороги из города в себя же.
Гарантируется, что изначальное количество штатов строго меньше n.

Формат выходных данных:

В единственной строке выведите целое число x.

*/ 

// объявление функции с параметрами
function canDivideIntoStates(n, m, roads, x) {
    // создание массива длиной n и заполнение его значениями -1
    const parent = Array(n).fill(-1);

    // объявление внутренней функции с параметром
    function findRoot(city) {
        // если значение в массиве parent для города равно -1, возвращаем сам город
        if (parent[city] === -1) return city;
        // в противном случае находим корень города и устанавливаем его как корень для города
        return parent[city] = findRoot(parent[city]);
    }

    // инициализация переменной components значением n
    let components = n;

    // итерация по массиву roads длиной m
    for (let i = 0; i < m; i++) {
        // деструктуризация массива в переменные u, v и w
        const [u, v, w] = roads[i];
        // если вес w меньше или равен x
        if (w <= x) {
            // находим корни для узлов u и v
            const rootU = findRoot(u - 1);
            const rootV = findRoot(v - 1);
            // если корни не равны, объединяем компоненты и уменьшаем components
            if (rootU !== rootV) {
                parent[rootV] = rootU;
                components--;
            }
        }
    }

    // возвращаем результат сравнения components с 1
    return components === 1;
}

// объявление функции с параметрами n, m и roads
function findOptimalX(n, m, roads) {
    // инициализация переменных
    let left = 0;
    let right = 1e9;

    // пока left меньше right выполняется цикл
    while (left < right) {
        // вычисление среднего значения между left и right
        const mid = Math.floor((left + right) / 2);
        // если можно разделить города на компоненты с x равным mid, уменьшаем right
        if (canDivideIntoStates(n, m, roads, mid)) {
            right = mid;
        } else {
            // иначе увеличиваем left
            left = mid + 1;
        }
    }

    // возвращаем значение left как оптимальное значение x
    return left;
}

// импорт модуля и создание интерфейса для ввода и вывода
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// ожидание ввода строки
rl.question('', (nm) => {
    // разбиваем строку на числа n и m
    const [n, m] = nm.split(' ').map(Number);
    // инициализация массива 
    const roads = [];

    // вывод пустой строки
    console.log('');

    // ожидание ввода строк через событие
    rl.on('line', (line) => {
        // разбиваем строку line на числа v, u и w и добавляем их в массив roads
        const [v, u, w] = line.split(' ').map(Number);
        roads.push([v, u, w]);

        // если количество строк достигло m, закрываем интерфейс и находим оптимальное значение x
        if (roads.length === m) {
            rl.close();
            const result = findOptimalX(n, m, roads);
            // выводим результат
            console.log('', result);
        }
    });
});

